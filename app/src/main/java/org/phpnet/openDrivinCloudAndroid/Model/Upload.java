package org.phpnet.openDrivinCloudAndroid.Model;

import android.os.Parcel;
import android.os.Parcelable;

import java.io.File;
import java.util.Date;

import io.realm.RealmList;
import io.realm.RealmObject;
import io.realm.annotations.PrimaryKey;
/**
 * Created by clement on 26/07/16.
 *
 * Some of the code comes from OwnCloud android app
 * https://github.com/owncloud/android
 */

public class Upload extends RealmObject implements Parcelable {
    public static final String FIELD_SIZE = "size";
    public static final String FIELD_OVERWRITE = "overwrite";
    public static final String FIELD_CREATE_PATH = "createPath";
    public static final String FIELD_START_DATE = "startDate";
    public static final String FIELD_END_TIME = "endTime";
    public static final String FIELD_AVERAGE_SPEED = "averageSpeed";
    public static final String FIELD_CANCELED = "canceled";
    public static final String FIELD_PROGRESS = "progress";
    public static final String FIELD_ELAPSED_TIME = "elapsedTime";
    public static final String FIELD_SENT = "sent";
    public static final String FIELD_SERVER_RESPONSE_CODE = "serverResponseCode";
    public static final String FIELD_ERROR = "error";

    /* Relation */
    public Account account;
    public Sync sync = null; //Set only if uploads commandited by syncOp, stays to null otherwise
    public RealmList<FileUpload> files;

    @PrimaryKey public String uId; //The uploads id generated by the uploads service

    //Local and distant path : Must be full path
    public long size = 0;
    public boolean overwrite = false;
    public boolean createPath = true; // If the leading folder(s) doesn't exist, create them
    public Date startDate;
    public Date endTime;
    public long averageSpeed;
    public boolean canceled = false;
    public int progress = 0;
    public String elapsedTime;
    public long sent;
    public int serverResponseCode;
    public String error;




    //We user raw string to handle the enum serialisation
    private String rawStatus;
    private String rawSource;
    private String rawPriority;

    public Upload(){}


    protected Upload(Parcel in) {
        account = in.readParcelable(Account.class.getClassLoader());
        sync = in.readParcelable(Sync.class.getClassLoader());
        uId = in.readString();
        size = in.readLong();
        overwrite = in.readByte() != 0;
        createPath = in.readByte() != 0;
        averageSpeed = in.readLong();
        rawStatus = in.readString();
        rawSource = in.readString();
        rawPriority = in.readString();
        sent = in.readLong();
        serverResponseCode = in.readInt();
        canceled = in.readByte() != 0;
        error = in.readString();
        progress = in.readInt();
        elapsedTime = in.readString();
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(account, flags);
        dest.writeParcelable(sync, flags);
        dest.writeString(uId);
        dest.writeLong(size);
        dest.writeByte((byte) (overwrite ? 1 : 0));
        dest.writeByte((byte) (createPath ? 1 : 0));
        dest.writeLong(averageSpeed);
        dest.writeString(rawStatus);
        dest.writeString(rawSource);
        dest.writeString(rawPriority);
        dest.writeLong(sent);
        dest.writeInt(serverResponseCode);
        dest.writeByte((byte) (canceled ? 1 : 0));
        dest.writeString(error);
        dest.writeInt(progress);
        dest.writeString(elapsedTime);
    }

    public static final Creator<Upload> CREATOR = new Creator<Upload>() {
        @Override
        public Upload createFromParcel(Parcel in) {
            return new Upload(in);
        }

        @Override
        public Upload[] newArray(int size) {
            return new Upload[size];
        }
    };

    /**
     * Set to true if you want to override eventual files, default is false
     */
    public void setOverwrite(boolean overwrite){
        this.overwrite = overwrite;
    }

    /**
     * Set to true if you want to create folders in path if they dont exist default id true
     */
    public void setCreatePath(boolean createPath){
        this.createPath = createPath;
    }

    public boolean isOverwrite() {
        return overwrite;
    }

    public boolean isCreatePath() {
        return createPath;
    }

    /**
     * Creates a new Upload with a single file or a directory
     * @param account The account that will be used to execute the operation
     * @param localPath The path to the file / directory to uploads
     * @param distPath The distant path of the file (If the path doesn't exist,
     *                 see <a href="#setCreatePath">setCreatePath</a>)
     *                 In case of unique file, you can use distPath to set the name of your file on
     *                 the server.
     */
    public Upload(Account account, String localPath, String distPath) {
        if (localPath == null || !localPath.startsWith(File.separator)) {
            throw new IllegalArgumentException("Local path must be an absolute path in the local file system");
        }
        if (distPath == null || !distPath.startsWith(File.separator)) {
            throw new IllegalArgumentException("Remote path must be an absolute path in the local file system");
        }
        if(account == null){
            throw new IllegalArgumentException("Account parameter is mandatory");
        }

        this.account = account;
    }

    /**
     * Create a new uploads with multiples local & destination paths
     * @param account The account that will be used to execute the operation
     * @param localPaths The path to the file / directory to uploads
     * @param distPaths The distant path of the file (If the path doesn't exist,
     *                  see <a href="#setCreatePath">setCreatePath</a>
     *                  2 options:
     *                  - One distant path for each local path
     *                  - One unique distant path for every local paths
     */
    public Upload(Account account, String[] localPaths, String[] distPaths){
        if( //One distPath per file or one distPath for all the files.
                distPaths.length != localPaths.length && distPaths.length != 1) {
            throw new IllegalArgumentException("You must provide whether : \n" +
                    "- One distant path for each local path \n" +
                    "- One unique distant path for every local path \n" +
                    "(Retrieved "+localPaths.length+" local paths and "+distPaths.length+
                    " distant paths)");
        }
        if(localPaths == null || localPaths.length < 1) {
            throw new IllegalArgumentException("localPaths cannot null/empty");
        }
        if(distPaths == null || distPaths.length < 1){
            throw new IllegalArgumentException("distPaths cannot be null/empty");
        }
    }

    public Account getAccount() {
        return account;
    }

    @Override
    public int describeContents() {
        return 0;
    }

}
